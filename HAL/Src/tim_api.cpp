#include "tim_api.h"

/**
 * @brief Get the APB Timer Clock Frequency
 * @note this all depends on the MCU clock configuration setup.
 *
 * APB1 @ 90MHz: Timer 2, 3, 4, 5, 6, 7, 12, 13, 14
 * APB2 @ 180MHz: Timer 1, 8, 9, 10, 11
 *
 * @param htim
 * @return uint32_t
 */
uint32_t tim_get_APBx_freq(TIM_HandleTypeDef *htim) {
    uint32_t pclk;
    if (htim->Instance == TIM1 || htim->Instance == TIM8 || htim->Instance == TIM9 || htim->Instance == TIM10 || htim->Instance == TIM11)
    {
        pclk = HAL_RCC_GetPCLK2Freq();
    }
    else // Timer 2, 3, 4, 5, 6, 7, 12, 13, 14
    {
        pclk = HAL_RCC_GetPCLK1Freq();
    }
    return pclk * 2; // Timer clocks are always equal to PCLK * 2 (see CubeMX clock config)
}

/**
 * @brief Get the freqeuncy of TIMx
 * OverflowEvent = APBx / ((period + 1) * (prescaler + 1))
 * NOTE: return math is off... not sure how to properly calculate
 * 
 * @param TIM_HandleTypeDef
 * @return uint32_t frequency
 */
uint32_t tim_get_overflow_freq(TIM_HandleTypeDef *htim)
{
    uint16_t prescaler = htim->Instance->PSC;
    uint32_t period = __HAL_TIM_GET_AUTORELOAD(htim);
    
    uint32_t APBx_freq = tim_get_APBx_freq(htim);

    return APBx_freq / ((prescaler + 1) * (period + 1));
}

/**
 * @brief set the prescaler and period of a timer based on a target frequency
 *
 * @note If this function starts recursively calling itself, it can someimes crash the program
 * The initial prescaler values plays a large part in this
 * @note Recursive Functions: Recursive functions that call themselves without a proper termination condition or with a large number of recursive calls can quickly consume stack space and lead to a stack overflow.
 *
 * period = APBx / (prescaler * target_frequency)
 *
 * TODO: when period gets set to less than 1, than target frequency is not possible given the current prescaler value.
 * So subtract the prescaler value by 1 and try again until target frequency can be achieved.
 *
 * @param htim
 * @param target_freq
 */
void tim_set_overflow_freq(TIM_HandleTypeDef *htim, uint32_t target_freq) {
    uint16_t prescaler = htim->Instance->PSC;
    uint32_t APBx_freq = tim_get_APBx_freq(htim);
    uint32_t period = APBx_freq / ((prescaler + 1) * target_freq);

    if (period > BIT_MAX_16) // adjust prescaler and recursively call this function
    { 
        __HAL_TIM_SET_PRESCALER(htim, prescaler + 1);
        vTaskDelay(1);
        tim_set_overflow_freq(htim, target_freq);
        return;
    } else if (period < 1000) {
        __HAL_TIM_SET_PRESCALER(htim, prescaler - 1);
        vTaskDelay(1);
        tim_set_overflow_freq(htim, target_freq);
        return;
    }
    __HAL_TIM_SetCounter(htim, 0);
    __HAL_TIM_SET_AUTORELOAD(htim, period);
}

/**
 * @brief
 * 1) Enables the TIM peripheral clock
 * 2) Sets the priority of the interrupt associated with the TIM peripheral
 * 3) Enables the interrupt request for the TIM peripheral. Once enabled, the microcontroller will respond to interrupts generated by TIM.
 * @param instance  ex. TIM7
 */
void tim_enable(TIM_TypeDef *instance) {
    if (instance == TIM6) {
        __HAL_RCC_TIM6_CLK_ENABLE();
        HAL_NVIC_SetPriority(TIM6_DAC_IRQn, RTOS_ISR_DEFAULT_PRIORITY, 0); // This function sets the priority of the interrupt associated with the TIM peripheral
        HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);         // This function enables the interrupt request for the TIM peripheral. Once enabled, the microcontroller will respond to interrupts generated by TIM6. This function allows the processor to respond to the interrupt request when it occurs.
    } else if (instance == TIM7) {
        __HAL_RCC_TIM7_CLK_ENABLE();
        HAL_NVIC_SetPriority(TIM7_IRQn, RTOS_ISR_DEFAULT_PRIORITY, 0);
        HAL_NVIC_EnableIRQ(TIM7_IRQn);
    } else if (instance == TIM9) {
        __HAL_RCC_TIM9_CLK_ENABLE();
        HAL_NVIC_SetPriority(TIM1_BRK_TIM9_IRQn, RTOS_ISR_DEFAULT_PRIORITY, 0);
        HAL_NVIC_EnableIRQ(TIM1_BRK_TIM9_IRQn);
    }
    else if (instance == TIM10) {
        __HAL_RCC_TIM10_CLK_ENABLE();
        HAL_NVIC_SetPriority(TIM1_UP_TIM10_IRQn, RTOS_ISR_DEFAULT_PRIORITY, 0);
        HAL_NVIC_EnableIRQ(TIM1_UP_TIM10_IRQn);
    }
    else if (instance == TIM11) {
        __HAL_RCC_TIM11_CLK_ENABLE();
        HAL_NVIC_SetPriority(TIM1_TRG_COM_TIM11_IRQn, RTOS_ISR_DEFAULT_PRIORITY, 0);
        HAL_NVIC_EnableIRQ(TIM1_TRG_COM_TIM11_IRQn);
    } else {
        return;
    }
}

/**
 * @brief Timer overflow callback
 * @note This function should not be modified, when the callback is needed, OK_TIM_PeriodElapsedCallback should be implemented in the user file
 * @param htim
 * @return __weak
 */
__weak void OK_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    /* Prevent unused argument(s) compilation warning */
    UNUSED(htim);
}

/**
 * @brief Input Capture Callback for all TIMx configured in Input Capture mode
 * @note This function should not be modified, when the callback is needed, OK_TIM_IC_CaptureCallback should be implemented in the user file
 * @param htim
 * @return __weak
 */
__weak void OK_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
    /* Prevent unused argument(s) compilation warning */
    UNUSED(htim);
}

/**
 * @brief  Period elapsed callback in non blocking mode (when a TIM overflow interrupt gets triggered)
 * @note   Function addionally calls Metronome static function for instance specific code
 * @param  htim : TIM handle
 * @retval None
 */
extern "C" void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    Metronome::RouteOverflowCallback(htim);          // TIM2 and TIM4 are used for Metro
    HardwareTimer::RoutePeriodElapsedCallback(htim); // generic timers
    OK_TIM_PeriodElapsedCallback(htim);              // to be defined in user application
    if (htim->Instance == TIM5)                      // TIM5 is being used for HAL ticker ie. for all HAL Peripherals...
    {
        HAL_IncTick();                               // increment a global variable "uwTick" used as application time base.
    }
}

/**
 * @brief Input Capture Callback for all TIMx configured in Input Capture mode
 */
extern "C" void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
    Metronome::RouteCaptureCallback(htim);
    HardwareTimer::RouteCaptureCallback(htim);
    OK_TIM_IC_CaptureCallback(htim);
}

/**
 * @brief This function handles TIM6 global interrupt.
 */
extern "C" void TIM6_DAC_IRQHandler(void) {
    // HAL_TIM_IRQHandler(&htim6);
    HardwareTimer::RouteTimerGlobalInterrupt(TIM6);
}

extern "C" void TIM7_IRQHandler(void) {
    HardwareTimer::RouteTimerGlobalInterrupt(TIM7);
}

extern "C" void TIM1_BRK_TIM9_IRQHandler(void)
{
    HardwareTimer::RouteTimerGlobalInterrupt(TIM9);
}

extern "C" void TIM1_UP_TIM10_IRQHandler(void) {
    HardwareTimer::RouteTimerGlobalInterrupt(TIM10);
}

extern "C" void TIM1_TRG_COM_TIM11_IRQHandler(void) {
    HardwareTimer::RouteTimerGlobalInterrupt(TIM11);

}